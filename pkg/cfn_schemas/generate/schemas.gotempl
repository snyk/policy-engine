package cfn_schemas

type Type int

const (
	Unknown Type = iota
	Boolean
	Integer
	Number
	String
	Array
	Object
)

// A Schema correponds to a resource
type Schema struct {
	Properties map[string]*Reference
}

// A Reference is an abstract property; it must be resolved first.
type Reference struct {
	ref        string
	type_      Type
	properties map[string]*Reference
	items      *Reference
}

// A Property has items that can actually be read.
type Property struct {
	Type       Type
	Properties map[string]*Reference
	Items      *Reference
}

// Find or return the underlying property.
func (ref *Reference) Resolve() Property {
	if ref.ref == "" {
		return Property{
			Type:       ref.type_,
			Properties: ref.properties,
			Items:      ref.items,
		}
	}

	if def, ok := definitions[ref.ref]; ok {
		return def.Resolve()
	} else {
		return Property{
			Type: Unknown,
		}
	}
}

{{ define "reference" }}&Reference{
{{- if .IsRef }}
	ref: "{{ .Schema.TypeName }}_{{ .GetRef }}",
{{- else if .IsBoolean }}
	type_: Boolean,
{{- else if .IsInteger }}
	type_: Integer,
{{- else if .IsNumber }}
	type_: Number,
{{- else if .IsString }}
	type_: String,
{{- else if .IsArray }}
	type_: Array,
	items: {{ template "reference" .Items }},
{{- else if .IsObject }}
	type_: Object,
	properties: map[string]*Reference{
		{{- range $key, $value := .Properties }}
			"{{ $key }}": {{ template "reference" $value }},
		{{- end }}
	},
{{- else }}
	type_: Unknown,
{{- end }}
}
{{- end }}

var Schemas = map[string]Schema{
{{- range $key, $value := . }}
	"{{ $key }}": {
		Properties: map[string]*Reference{
			{{- range $key, $value := .Properties }}
				"{{ $key }}": {{ template "reference" $value }},
			{{- end }}
		},
	},
{{- end }}
}

var definitions = map[string]*Reference {
{{- range $key, $schema := . }}
{{- range $definition, $value := .Definitions }}
	"{{ $schema.TypeName }}_{{ $definition }}": {{ template "reference" $value }},
{{- end }}
{{- end }}
}
